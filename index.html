<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>CamView</title>
    <script src="https://unpkg.com/mqtt@5.3.4/dist/mqtt.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: #000;
            color: #fff;
            overflow: hidden;
        }

        #app {
            width: 100vw;
            height: 100vh;
            position: relative;
        }

        #videoContainer {
            width: calc(60% - 40px);
            height: calc(60% - 40px);
            position: absolute;
            top: 20px;
            left: 20px;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.3s ease;
            z-index: 999;
            overflow: hidden;
        }

        #videoContainer:not(.settings-open) {
            width: 100%;
            height: 100%;
            position: relative;
            top: 0;
            left: 0;
            z-index: 1;
        }
        
        .crop-overlay {
            position: absolute;
            pointer-events: none;
            z-index: 10;
        }

        #videoContainer.mqtt-error {
            border: 4px solid #f00;
        }

        video {
            max-width: 100%;
            max-height: 100%;
            object-fit: contain;
            position: relative;
            z-index: 1;
        }

        .error-message {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 0, 0, 0.8);
            padding: 20px;
            border-radius: 8px;
            text-align: center;
            max-width: 500px;
        }

        #settingsButton {
            position: absolute;
            top: 20px;
            right: 20px;
            background: rgba(255, 255, 255, 0.1);
            border: none;
            border-radius: 50%;
            width: 48px;
            height: 48px;
            cursor: pointer;
            opacity: 0;
            transition: opacity 0.3s, background 0.3s;
            font-size: 24px;
        }

        #settingsButton:hover {
            background: rgba(255, 255, 255, 0.2);
        }

        #app:hover #settingsButton {
            opacity: 1;
        }

        #recordingIndicator {
            position: absolute;
            top: 20px;
            right: 80px;
            display: none;
            align-items: center;
            gap: 10px;
            background: rgba(0, 0, 0, 0.7);
            padding: 8px 16px;
            border-radius: 24px;
        }

        #recordingIndicator.recording {
            display: flex;
        }

        .rec-dot {
            width: 16px;
            height: 16px;
            background: #f00;
            border-radius: 50%;
            animation: pulse 1s infinite;
        }

        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.3; }
        }

        #settingsPanel {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: transparent;
            z-index: 1000;
        }

        #settingsPanel.open {
            display: block;
        }

        .settings-layout {
            display: grid;
            grid-template-columns: 60% 40%;
            grid-template-rows: 60% 40%;
            height: 100%;
            gap: 20px;
            padding: 20px;
        }

        .settings-video {
            grid-column: 1;
            grid-row: 1;
            pointer-events: none;
        }

        .settings-controls {
            grid-column: 1;
            grid-row: 2;
            display: flex;
            flex-direction: column;
            gap: 20px;
            position: relative;
            z-index: 1001;
            background: rgba(26, 26, 26, 0.95);
            border-radius: 8px;
            padding: 15px;
        }

        .settings-sidebar {
            grid-column: 2;
            grid-row: 1 / 3;
            overflow-y: auto;
            padding: 20px;
            background: #2a2a2a;
            border-radius: 8px;
            position: relative;
            z-index: 1001;
        }

        .close-button {
            float: right;
            background: #f44336;
            border: none;
            color: white;
            padding: 8px 16px;
            border-radius: 4px;
            cursor: pointer;
            margin-bottom: 20px;
        }

        .settings-section {
            background: #333;
            padding: 15px;
            border-radius: 8px;
            margin-bottom: 15px;
        }

        .settings-section h3 {
            margin-bottom: 15px;
            font-size: 16px;
            border-bottom: 1px solid #555;
            padding-bottom: 8px;
        }

        .setting-item {
            margin-bottom: 12px;
        }

        .setting-item label {
            display: block;
            margin-bottom: 4px;
            font-size: 14px;
            color: #ccc;
        }

        .setting-item input[type="number"],
        .setting-item input[type="text"],
        .setting-item input[type="color"],
        .setting-item select {
            width: 100%;
            padding: 6px;
            background: #444;
            border: 1px solid #555;
            color: #fff;
            border-radius: 4px;
        }

        .setting-item input[type="range"] {
            width: 100%;
        }

        .checkbox-list {
            display: flex;
            flex-direction: column;
            gap: 8px;
        }

        .checkbox-item {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .checkbox-item input[type="checkbox"] {
            width: 18px;
            height: 18px;
        }

        .video-list {
            display: flex;
            flex-direction: column;
            gap: 10px;
        }

        .video-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            background: #444;
            padding: 10px;
            border-radius: 4px;
        }

        .video-item-buttons {
            display: flex;
            gap: 8px;
        }

        button {
            background: #4CAF50;
            border: none;
            color: white;
            padding: 8px 16px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 14px;
        }

        button:hover {
            opacity: 0.8;
        }

        button.danger {
            background: #f44336;
        }

        button.secondary {
            background: #2196F3;
        }

        .mqtt-button {
            background: #9C27B0;
        }

        textarea {
            width: 100%;
            min-height: 100px;
            background: #444;
            border: 1px solid #555;
            color: #fff;
            border-radius: 4px;
            padding: 8px;
            font-family: monospace;
            font-size: 12px;
        }

        #modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.8);
            z-index: 2000;
            align-items: center;
            justify-content: center;
        }

        #modal.open {
            display: flex;
        }

        .modal-content {
            background: #2a2a2a;
            padding: 30px;
            border-radius: 8px;
            max-width: 500px;
            width: 90%;
            max-height: 80vh;
            overflow-y: auto;
        }

        .modal-buttons {
            display: flex;
            gap: 10px;
            margin-top: 20px;
            justify-content: flex-end;
        }

        .select-video-list {
            display: flex;
            flex-direction: column;
            gap: 10px;
            margin: 20px 0;
        }

        .select-video-item {
            background: #444;
            padding: 12px;
            border-radius: 4px;
            cursor: pointer;
            transition: background 0.2s;
        }

        .select-video-item:hover {
            background: #555;
        }

        .range-group {
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .range-group input[type="range"] {
            flex: 1;
        }

        .range-group span {
            min-width: 50px;
            text-align: right;
            font-size: 12px;
        }

        #cameraSelection {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: #1a1a1a;
            z-index: 3000;
            display: none;
            align-items: center;
            justify-content: center;
        }

        #cameraSelection.open {
            display: flex;
        }

        .camera-selection-content {
            background: #2a2a2a;
            padding: 40px;
            border-radius: 8px;
            max-width: 600px;
            width: 90%;
        }

        .camera-selection-content h2 {
            margin-bottom: 20px;
        }
    </style>
</head>
<body>
    <div id="app">
        <div id="videoContainer">
            <video id="video" autoplay playsinline muted></video>
            <div id="errorMessage" class="error-message" style="display: none;"></div>
        </div>

        <button id="settingsButton">⚙️</button>

        <div id="recordingIndicator">
            <div class="rec-dot"></div>
            <span id="recordingTime">0:00</span>
        </div>

        <div id="settingsPanel">
            <div class="settings-layout">
                <div class="settings-video">
                </div>

                <div class="settings-controls">
                    <div class="settings-section">
                        <h3>カメラ選択</h3>
                        <div id="cameraCheckboxList" class="checkbox-list"></div>
                    </div>

                    <div class="settings-section">
                        <h3>録画管理</h3>
                        <div id="videoList" class="video-list"></div>
                    </div>
                </div>

                <div class="settings-sidebar">
                    <button class="close-button" id="closeSettings">閉じる</button>
                    
                    <div class="settings-section">
                        <h3>変形・回転</h3>
                        <div class="setting-item">
                            <label>
                                <input type="checkbox" id="flipH"> 水平反転
                            </label>
                        </div>
                        <div class="setting-item">
                            <label>
                                <input type="checkbox" id="flipV"> 垂直反転
                            </label>
                        </div>
                        <div class="setting-item">
                            <label>回転</label>
                            <select id="rotate">
                                <option value="0">0°</option>
                                <option value="90">90°</option>
                                <option value="180">180°</option>
                                <option value="270">270°</option>
                            </select>
                        </div>
                    </div>

                    <div class="settings-section">
                        <h3>フィルター</h3>
                        <div class="setting-item">
                            <label>明度</label>
                            <div class="range-group">
                                <input type="range" id="brightness" min="0" max="200" value="100">
                                <span id="brightnessValue">100%</span>
                            </div>
                        </div>
                        <div class="setting-item">
                            <label>コントラスト</label>
                            <div class="range-group">
                                <input type="range" id="contrast" min="0" max="200" value="100">
                                <span id="contrastValue">100%</span>
                            </div>
                        </div>
                        <div class="setting-item">
                            <label>色相</label>
                            <div class="range-group">
                                <input type="range" id="hueRotate" min="0" max="360" value="0">
                                <span id="hueRotateValue">0°</span>
                            </div>
                        </div>
                        <div class="setting-item">
                            <label>彩度</label>
                            <div class="range-group">
                                <input type="range" id="saturate" min="0" max="200" value="100">
                                <span id="saturateValue">100%</span>
                            </div>
                        </div>
                        <div class="setting-item">
                            <label>ぼかし</label>
                            <div class="range-group">
                                <input type="range" id="blur" min="0" max="20" value="0">
                                <span id="blurValue">0px</span>
                            </div>
                        </div>
                        <div class="setting-item">
                            <label>セピア</label>
                            <div class="range-group">
                                <input type="range" id="sepia" min="0" max="100" value="0">
                                <span id="sepiaValue">0%</span>
                            </div>
                        </div>
                        <div class="setting-item">
                            <label>グレースケール</label>
                            <div class="range-group">
                                <input type="range" id="grayscale" min="0" max="100" value="0">
                                <span id="grayscaleValue">0%</span>
                            </div>
                        </div>
                        <div class="setting-item">
                            <label>不透明度</label>
                            <div class="range-group">
                                <input type="range" id="opacity" min="0" max="100" value="100">
                                <span id="opacityValue">100%</span>
                            </div>
                        </div>
                        <div class="setting-item">
                            <label>反転</label>
                            <div class="range-group">
                                <input type="range" id="invert" min="0" max="100" value="0">
                                <span id="invertValue">0%</span>
                            </div>
                        </div>
                    </div>

                    <div class="settings-section">
                        <h3>表示領域</h3>
                        <div class="setting-item">
                            <label>X1</label>
                            <input type="number" id="sizeX1" min="0" max="1920" value="0">
                        </div>
                        <div class="setting-item">
                            <label>Y1</label>
                            <input type="number" id="sizeY1" min="0" max="1080" value="0">
                        </div>
                        <div class="setting-item">
                            <label>X2</label>
                            <input type="number" id="sizeX2" min="0" max="1920" value="1920">
                        </div>
                        <div class="setting-item">
                            <label>Y2</label>
                            <input type="number" id="sizeY2" min="0" max="1080" value="1080">
                        </div>
                        <div class="setting-item">
                            <label>背景色</label>
                            <input type="color" id="backgroundColor" value="#000000">
                        </div>
                    </div>

                    <div class="settings-section">
                        <h3>MQTT設定</h3>
                        <button class="mqtt-button" id="openMqttSettings">MQTT接続設定</button>
                    </div>

                    <div class="settings-section">
                        <h3>エクスポート/インポート</h3>
                        <button id="exportSettings">エクスポート</button>
                        <button class="secondary" id="importSettings" style="margin-top: 10px;">インポート</button>
                        <textarea id="settingsJson" style="margin-top: 10px;" placeholder="設定JSON"></textarea>
                    </div>
                </div>
            </div>
        </div>

        <div id="cameraSelection">
            <div class="camera-selection-content">
                <h2>カメラを選択してください</h2>
                <div id="initialCameraList" class="checkbox-list"></div>
                <div style="margin-top: 20px;">
                    <button id="confirmCameraSelection">決定</button>
                </div>
            </div>
        </div>

        <div id="modal">
            <div class="modal-content">
                <h3 id="modalTitle"></h3>
                <div id="modalBody"></div>
                <div class="modal-buttons">
                    <button id="modalCancel" class="danger">キャンセル</button>
                    <button id="modalConfirm">OK</button>
                </div>
            </div>
        </div>
    </div>

    <script>
        // グローバル変数
        let mediaStream = null;
        let mediaRecorder = null;
        let recordedChunks = [];
        let recordingStartTime = 0;
        let recordingTimer = null;
        let mqttClient = null;
        let mqttConnected = false;
        let currentCameraIndex = 0;
        let selectedCameras = [];
        let allCameras = [];
        let cameraSettings = {};
        let db = null;
        let isPlayingRecording = false;
        let currentPlayingIndex = -1;

        const MAX_RECORDING_DURATION = 60000; // 60秒
        const MAX_RECORDINGS = 3;

        // IndexedDB初期化
        function initDB() {
            return new Promise((resolve, reject) => {
                const request = indexedDB.open('CamViewDB', 1);
                
                request.onerror = () => reject(request.error);
                request.onsuccess = () => {
                    db = request.result;
                    resolve(db);
                };
                
                request.onupgradeneeded = (event) => {
                    const db = event.target.result;
                    if (!db.objectStoreNames.contains('recordings')) {
                        db.createObjectStore('recordings', { keyPath: 'id', autoIncrement: true });
                    }
                };
            });
        }

        // 録画データの保存
        async function saveRecording(blob, timestamp) {
            return new Promise((resolve, reject) => {
                const transaction = db.transaction(['recordings'], 'readwrite');
                const store = transaction.objectStore('recordings');
                const request = store.add({ blob, timestamp });
                
                request.onsuccess = () => resolve(request.result);
                request.onerror = () => reject(request.error);
            });
        }

        // 録画データの取得
        async function getRecordings() {
            return new Promise((resolve, reject) => {
                const transaction = db.transaction(['recordings'], 'readonly');
                const store = transaction.objectStore('recordings');
                const request = store.getAll();
                
                request.onsuccess = () => resolve(request.result);
                request.onerror = () => reject(request.error);
            });
        }

        // 録画データの削除
        async function deleteRecording(id) {
            return new Promise((resolve, reject) => {
                const transaction = db.transaction(['recordings'], 'readwrite');
                const store = transaction.objectStore('recordings');
                const request = store.delete(id);
                
                request.onsuccess = () => resolve();
                request.onerror = () => reject(request.error);
            });
        }

        // LocalStorageから設定を読み込み
        function loadSettings() {
            const saved = localStorage.getItem('camViewSettings');
            if (saved) {
                const settings = JSON.parse(saved);
                cameraSettings = settings.cameraSettings || {};
                selectedCameras = settings.selectedCameras || [];
                currentCameraIndex = settings.currentCameraIndex || 0;
                return settings;
            }
            return null;
        }

        // LocalStorageに設定を保存
        function saveSettings() {
            const settings = {
                cameraSettings,
                selectedCameras,
                currentCameraIndex,
                mqttSettings: getMqttSettings()
            };
            localStorage.setItem('camViewSettings', JSON.stringify(settings));
        }

        // MQTT設定の取得
        function getMqttSettings() {
            const saved = localStorage.getItem('mqttSettings');
            return saved ? JSON.parse(saved) : null;
        }

        // MQTT設定の保存
        function saveMqttSettings(settings) {
            localStorage.setItem('mqttSettings', JSON.stringify(settings));
        }

        // カメラリストの取得
        async function getCameras() {
            try {
                await navigator.mediaDevices.getUserMedia({ video: true });
                const devices = await navigator.mediaDevices.enumerateDevices();
                return devices.filter(device => device.kind === 'videoinput');
            } catch (error) {
                showError('カメラへのアクセスが拒否されました', error.message);
                return [];
            }
        }

        // カメラストリームの開始
        async function startCamera(deviceId) {
            try {
                if (mediaStream) {
                    mediaStream.getTracks().forEach(track => track.stop());
                }

                const constraints = {
                    video: {
                        deviceId: deviceId ? { exact: deviceId } : undefined,
                        width: { ideal: 1920 },
                        height: { ideal: 1080 }
                    }
                };

                mediaStream = await navigator.mediaDevices.getUserMedia(constraints);
                const video = document.getElementById('video');
                video.srcObject = mediaStream;
                
                hideError();
                
                // ビデオのメタデータが読み込まれたら設定を適用
                video.onloadedmetadata = () => {
                    applyVideoSettings();
                };
                
                return true;
            } catch (error) {
                showError('カメラの起動に失敗しました', error.message);
                return false;
            }
        }

        // ビデオ設定の適用
        function applyVideoSettings() {
            const camera = selectedCameras[currentCameraIndex];
            if (!camera) return;

            const settings = cameraSettings[camera.deviceId] || getDefaultSettings();
            const video = document.getElementById('video');
            const container = document.getElementById('videoContainer');

            // ビデオの実サイズを取得
            const videoWidth = video.videoWidth;
            const videoHeight = video.videoHeight;
            
            if (!videoWidth || !videoHeight) {
                // メタデータがまだ読み込まれていない場合は後で再試行
                setTimeout(() => applyVideoSettings(), 100);
                return;
            }

            // フィルター適用
            let filters = [];
            filters.push(`brightness(${settings.brightness}%)`);
            filters.push(`contrast(${settings.contrast}%)`);
            filters.push(`hue-rotate(${settings.hueRotate}deg)`);
            filters.push(`saturate(${settings.saturate}%)`);
            filters.push(`blur(${settings.blur}px)`);
            filters.push(`sepia(${settings.sepia}%)`);
            filters.push(`grayscale(${settings.grayscale}%)`);
            filters.push(`opacity(${settings.opacity}%)`);
            filters.push(`invert(${settings.invert}%)`);
            video.style.filter = filters.join(' ');

            // 変形・回転
            let transform = [];
            if (settings.flipH) transform.push('scaleX(-1)');
            if (settings.flipV) transform.push('scaleY(-1)');
            if (settings.rotate !== 0) transform.push(`rotate(${settings.rotate}deg)`);
            video.style.transform = transform.join(' ');

            // 表示領域（クロップ）
            applyVideoCrop(settings);
        }

        // ビデオクロップの適用
        function applyVideoCrop(settings) {
            const video = document.getElementById('video');
            const container = document.getElementById('videoContainer');
            
            container.style.background = settings.backgroundColor;
            
            // ビデオの実サイズを取得
            const videoWidth = video.videoWidth;
            const videoHeight = video.videoHeight;
            
            if (!videoWidth || !videoHeight) {
                // メタデータが読み込まれていない場合は待つ
                requestAnimationFrame(() => applyVideoCrop(settings));
                return;
            }
            
            // 既存のオーバーレイを削除
            const existingOverlays = container.querySelectorAll('.crop-overlay');
            existingOverlays.forEach(overlay => overlay.remove());
            
            // カメラ映像を100%表示
            video.style.width = '100%';
            video.style.height = '100%';
            video.style.maxWidth = '';
            video.style.maxHeight = '';
            video.style.objectFit = 'cover';
            video.style.position = 'absolute';
            video.style.left = '0';
            video.style.top = '0';
            video.style.clipPath = 'none';
            
            if (settings.sizeX1 !== 0 || settings.sizeY1 !== 0 || 
                settings.sizeX2 !== 1920 || settings.sizeY2 !== 1080) {
                
                // クロップ領域が指定されている場合、オーバーレイを作成
                const containerWidth = container.clientWidth;
                const containerHeight = container.clientHeight;
                
                if (!containerWidth || !containerHeight) {
                    requestAnimationFrame(() => applyVideoCrop(settings));
                    return;
                }
                
                // 1920x1080基準からコンテナサイズへの変換比率
                const scaleX = containerWidth / 1920;
                const scaleY = containerHeight / 1080;
                
                const x1 = settings.sizeX1 * scaleX;
                const y1 = settings.sizeY1 * scaleY;
                const x2 = settings.sizeX2 * scaleX;
                const y2 = settings.sizeY2 * scaleY;
                
                // 4つの長方形を作成
                const overlays = [
                    // 左側: 0,0 - x1,containerHeight
                    { left: 0, top: 0, width: x1, height: containerHeight },
                    // 上側: x1,0 - x2,y1
                    { left: x1, top: 0, width: x2 - x1, height: y1 },
                    // 右側: x2,0 - containerWidth,containerHeight
                    { left: x2, top: 0, width: containerWidth - x2, height: containerHeight },
                    // 下側: x1,y2 - x2,containerHeight
                    { left: x1, top: y2, width: x2 - x1, height: containerHeight - y2 }
                ];
                
                overlays.forEach((rect, index) => {
                    if (rect.width > 0 && rect.height > 0) {
                        const overlay = document.createElement('div');
                        overlay.className = 'crop-overlay';
                        overlay.style.left = `${rect.left}px`;
                        overlay.style.top = `${rect.top}px`;
                        overlay.style.width = `${rect.width}px`;
                        overlay.style.height = `${rect.height}px`;
                        overlay.style.backgroundColor = settings.backgroundColor;
                        container.appendChild(overlay);
                    }
                });
            }
        }

        // デフォルト設定
        function getDefaultSettings() {
            return {
                flipH: false,
                flipV: false,
                rotate: 0,
                brightness: 100,
                contrast: 100,
                hueRotate: 0,
                saturate: 100,
                blur: 0,
                sepia: 0,
                grayscale: 0,
                opacity: 100,
                invert: 0,
                sizeX1: 0,
                sizeY1: 0,
                sizeX2: 1920,
                sizeY2: 1080,
                backgroundColor: '#000000'
            };
        }

        // カメラ切り替え
        function switchCamera(direction) {
            if (selectedCameras.length === 0) return;
            
            currentCameraIndex += direction;
            if (currentCameraIndex < 0) currentCameraIndex = selectedCameras.length - 1;
            if (currentCameraIndex >= selectedCameras.length) currentCameraIndex = 0;
            
            const camera = selectedCameras[currentCameraIndex];
            startCamera(camera.deviceId);
            saveSettings();
        }

        // 録画開始
        async function startRecording() {
            if (!mediaStream || isPlayingRecording) return;

            const recordings = await getRecordings();
            if (recordings.length >= MAX_RECORDINGS) {
                showSelectVideoToDelete();
                return;
            }

            recordedChunks = [];
            
            try {
                mediaRecorder = new MediaRecorder(mediaStream, {
                    mimeType: 'video/webm;codecs=vp9'
                });
            } catch (e) {
                mediaRecorder = new MediaRecorder(mediaStream);
            }

            mediaRecorder.ondataavailable = (event) => {
                if (event.data.size > 0) {
                    recordedChunks.push(event.data);
                }
            };

            mediaRecorder.onstop = async () => {
                const blob = new Blob(recordedChunks, { type: 'video/webm' });
                await saveRecording(blob, Date.now());
                updateVideoList();
            };

            mediaRecorder.start();
            recordingStartTime = Date.now();
            
            document.getElementById('recordingIndicator').classList.add('recording');
            
            recordingTimer = setInterval(() => {
                const elapsed = Date.now() - recordingStartTime;
                const seconds = Math.floor(elapsed / 1000);
                const minutes = Math.floor(seconds / 60);
                const secs = seconds % 60;
                document.getElementById('recordingTime').textContent = 
                    `${minutes}:${secs.toString().padStart(2, '0')}`;
                
                if (elapsed >= MAX_RECORDING_DURATION) {
                    stopRecording();
                }
            }, 100);
        }

        // 録画停止
        function stopRecording() {
            if (mediaRecorder && mediaRecorder.state !== 'inactive') {
                mediaRecorder.stop();
            }
            
            if (recordingTimer) {
                clearInterval(recordingTimer);
                recordingTimer = null;
            }
            
            document.getElementById('recordingIndicator').classList.remove('recording');
        }

        // 録画削除選択モーダル
        async function showSelectVideoToDelete() {
            const recordings = await getRecordings();
            const modal = document.getElementById('modal');
            const modalTitle = document.getElementById('modalTitle');
            const modalBody = document.getElementById('modalBody');
            
            modalTitle.textContent = '削除する録画を選択';
            modalBody.innerHTML = '<div class="select-video-list"></div>';
            
            const list = modalBody.querySelector('.select-video-list');
            recordings.forEach((rec, index) => {
                const item = document.createElement('div');
                item.className = 'select-video-item';
                const date = new Date(rec.timestamp);
                item.textContent = `録画 ${index + 1} - ${date.toLocaleString()}`;
                item.onclick = async () => {
                    await deleteRecording(rec.id);
                    closeModal();
                    startRecording();
                };
                list.appendChild(item);
            });
            
            document.getElementById('modalConfirm').style.display = 'none';
            modal.classList.add('open');
        }

        // 録画再生
        async function playRecording(id) {
            const recordings = await getRecordings();
            const recording = recordings.find(r => r.id === id);
            if (!recording) return;

            if (mediaStream) {
                mediaStream.getTracks().forEach(track => track.stop());
            }

            const video = document.getElementById('video');
            const url = URL.createObjectURL(recording.blob);
            video.srcObject = null;
            video.src = url;
            video.loop = true;
            video.play();
            
            isPlayingRecording = true;
            currentPlayingIndex = id;
        }

        // ライブ映像に戻る
        function stopPlayback() {
            if (!isPlayingRecording) return;
            
            const video = document.getElementById('video');
            if (video.src) {
                URL.revokeObjectURL(video.src);
                video.src = '';
            }
            
            isPlayingRecording = false;
            currentPlayingIndex = -1;
            
            const camera = selectedCameras[currentCameraIndex];
            if (camera) {
                startCamera(camera.deviceId);
            }
        }

        // 録画リスト更新
        async function updateVideoList() {
            const recordings = await getRecordings();
            const list = document.getElementById('videoList');
            list.innerHTML = '';

            if (recordings.length === 0) {
                list.innerHTML = '<p style="color: #888;">録画がありません</p>';
                return;
            }

            recordings.forEach((rec, index) => {
                const item = document.createElement('div');
                item.className = 'video-item';
                
                const date = new Date(rec.timestamp);
                const info = document.createElement('span');
                info.textContent = `録画 ${index + 1} - ${date.toLocaleString()}`;
                
                const buttons = document.createElement('div');
                buttons.className = 'video-item-buttons';
                
                const playBtn = document.createElement('button');
                playBtn.textContent = '再生';
                playBtn.className = 'secondary';
                playBtn.onclick = () => {
                    playRecording(rec.id);
                    closeSettings();
                };
                
                const deleteBtn = document.createElement('button');
                deleteBtn.textContent = '削除';
                deleteBtn.className = 'danger';
                deleteBtn.onclick = async () => {
                    await deleteRecording(rec.id);
                    updateVideoList();
                };
                
                buttons.appendChild(playBtn);
                buttons.appendChild(deleteBtn);
                item.appendChild(info);
                item.appendChild(buttons);
                list.appendChild(item);
            });
        }

        // MQTT接続
        function connectMqtt(settings) {
            if (mqttClient) {
                mqttClient.end();
            }

            try {
                const options = {
                    clean: true,
                    clientId: 'camview_' + Math.random().toString(16).substr(2, 8),
                    will: {
                        topic: settings.willTopic,
                        payload: settings.willPayload,
                        qos: 0,
                        retain: true
                    }
                };

                if (settings.username) {
                    options.username = settings.username;
                    options.password = settings.password;
                }

                const url = `${settings.protocol || 'ws'}://${settings.host}:${settings.port}`;
                mqttClient = mqtt.connect(url, options);

                mqttClient.on('connect', () => {
                    mqttConnected = true;
                    document.getElementById('videoContainer').classList.remove('mqtt-error');
                    
                    // online メッセージをpublish
                    mqttClient.publish(settings.willTopic, 'online', { qos: 0, retain: true });
                    
                    // トピック購読
                    mqttClient.subscribe(`${settings.prefix}/camera`, { qos: 0 });
                    mqttClient.subscribe(`${settings.prefix}/video`, { qos: 0 });
                });

                mqttClient.on('error', (error) => {
                    mqttConnected = false;
                    document.getElementById('videoContainer').classList.add('mqtt-error');
                });

                mqttClient.on('close', () => {
                    mqttConnected = false;
                    document.getElementById('videoContainer').classList.add('mqtt-error');
                });

                mqttClient.on('message', async (topic, message) => {
                    const payload = message.toString();
                    
                    if (topic === `${settings.prefix}/camera`) {
                        const index = parseInt(payload);
                        if (!isNaN(index) && index >= 0 && index < selectedCameras.length) {
                            currentCameraIndex = index;
                            const camera = selectedCameras[currentCameraIndex];
                            await startCamera(camera.deviceId);
                            saveSettings();
                        }
                    } else if (topic === `${settings.prefix}/video`) {
                        const index = parseInt(payload);
                        if (!isNaN(index)) {
                            const recordings = await getRecordings();
                            if (index >= 0 && index < recordings.length) {
                                await playRecording(recordings[index].id);
                            }
                        }
                    }
                });

            } catch (error) {
                console.error('MQTT connection error:', error);
                mqttConnected = false;
                document.getElementById('videoContainer').classList.add('mqtt-error');
            }
        }

        // MQTT設定モーダルを開く
        function openMqttSettingsModal() {
            const settings = getMqttSettings() || {
                host: 'localhost',
                port: 9001,
                protocol: 'ws',
                prefix: 'camview/device1',
                willTopic: 'camview/device1/status',
                willPayload: 'away',
                username: '',
                password: ''
            };

            const modal = document.getElementById('modal');
            const modalTitle = document.getElementById('modalTitle');
            const modalBody = document.getElementById('modalBody');
            
            modalTitle.textContent = 'MQTT接続設定';
            modalBody.innerHTML = `
                <div class="setting-item">
                    <label>プロトコル</label>
                    <select id="mqttProtocol">
                        <option value="ws" ${settings.protocol === 'ws' ? 'selected' : ''}>WebSocket (ws)</option>
                        <option value="wss" ${settings.protocol === 'wss' ? 'selected' : ''}>WebSocket Secure (wss)</option>
                    </select>
                </div>
                <div class="setting-item">
                    <label>ホスト</label>
                    <input type="text" id="mqttHost" value="${settings.host}">
                </div>
                <div class="setting-item">
                    <label>ポート</label>
                    <input type="number" id="mqttPort" value="${settings.port}">
                </div>
                <div class="setting-item">
                    <label>トピックプレフィックス</label>
                    <input type="text" id="mqttPrefix" value="${settings.prefix}">
                </div>
                <div class="setting-item">
                    <label>Will トピック</label>
                    <input type="text" id="mqttWillTopic" value="${settings.willTopic}">
                </div>
                <div class="setting-item">
                    <label>Will ペイロード</label>
                    <input type="text" id="mqttWillPayload" value="${settings.willPayload}">
                </div>
                <div class="setting-item">
                    <label>ユーザー名（オプション）</label>
                    <input type="text" id="mqttUsername" value="${settings.username || ''}">
                </div>
                <div class="setting-item">
                    <label>パスワード（オプション）</label>
                    <input type="password" id="mqttPassword" value="${settings.password || ''}">
                </div>
            `;
            
            document.getElementById('modalConfirm').style.display = '';
            document.getElementById('modalConfirm').onclick = () => {
                const newSettings = {
                    protocol: document.getElementById('mqttProtocol').value,
                    host: document.getElementById('mqttHost').value,
                    port: parseInt(document.getElementById('mqttPort').value),
                    prefix: document.getElementById('mqttPrefix').value,
                    willTopic: document.getElementById('mqttWillTopic').value,
                    willPayload: document.getElementById('mqttWillPayload').value,
                    username: document.getElementById('mqttUsername').value,
                    password: document.getElementById('mqttPassword').value
                };
                
                saveMqttSettings(newSettings);
                connectMqtt(newSettings);
                closeModal();
            };
            
            modal.classList.add('open');
        }

        // モーダルを閉じる
        function closeModal() {
            document.getElementById('modal').classList.remove('open');
        }

        // エラー表示
        function showError(title, message) {
            const errorDiv = document.getElementById('errorMessage');
            errorDiv.innerHTML = `<h3>${title}</h3><p>${message}</p>`;
            errorDiv.style.display = 'block';
        }

        // エラー非表示
        function hideError() {
            document.getElementById('errorMessage').style.display = 'none';
        }

        // 設定画面を開く
        function openSettings() {
            document.getElementById('settingsPanel').classList.add('open');
            document.getElementById('videoContainer').classList.add('settings-open');
            loadSettingsToUI();
            updateVideoList();
            // CSSトランジション完了を待ってから再描画
            setTimeout(() => applyVideoSettings(), 350);
        }

        // 設定画面を閉じる
        function closeSettings() {
            document.getElementById('settingsPanel').classList.remove('open');
            document.getElementById('videoContainer').classList.remove('settings-open');
            saveSettingsFromUI();
            // CSSトランジション完了を待ってから再描画
            setTimeout(() => applyVideoSettings(), 350);
        }

        // UIから設定を保存
        function saveSettingsFromUI() {
            const camera = selectedCameras[currentCameraIndex];
            if (!camera) return;

            const settings = {
                flipH: document.getElementById('flipH').checked,
                flipV: document.getElementById('flipV').checked,
                rotate: parseInt(document.getElementById('rotate').value),
                brightness: parseInt(document.getElementById('brightness').value),
                contrast: parseInt(document.getElementById('contrast').value),
                hueRotate: parseInt(document.getElementById('hueRotate').value),
                saturate: parseInt(document.getElementById('saturate').value),
                blur: parseInt(document.getElementById('blur').value),
                sepia: parseInt(document.getElementById('sepia').value),
                grayscale: parseInt(document.getElementById('grayscale').value),
                opacity: parseInt(document.getElementById('opacity').value),
                invert: parseInt(document.getElementById('invert').value),
                sizeX1: parseInt(document.getElementById('sizeX1').value),
                sizeY1: parseInt(document.getElementById('sizeY1').value),
                sizeX2: parseInt(document.getElementById('sizeX2').value),
                sizeY2: parseInt(document.getElementById('sizeY2').value),
                backgroundColor: document.getElementById('backgroundColor').value
            };

            cameraSettings[camera.deviceId] = settings;
            saveSettings();
        }

        // 設定をUIに読み込み
        function loadSettingsToUI() {
            const camera = selectedCameras[currentCameraIndex];
            if (!camera) return;

            const settings = cameraSettings[camera.deviceId] || getDefaultSettings();

            document.getElementById('flipH').checked = settings.flipH;
            document.getElementById('flipV').checked = settings.flipV;
            document.getElementById('rotate').value = settings.rotate;
            document.getElementById('brightness').value = settings.brightness;
            document.getElementById('contrast').value = settings.contrast;
            document.getElementById('hueRotate').value = settings.hueRotate;
            document.getElementById('saturate').value = settings.saturate;
            document.getElementById('blur').value = settings.blur;
            document.getElementById('sepia').value = settings.sepia;
            document.getElementById('grayscale').value = settings.grayscale;
            document.getElementById('opacity').value = settings.opacity;
            document.getElementById('invert').value = settings.invert;
            document.getElementById('sizeX1').value = settings.sizeX1;
            document.getElementById('sizeY1').value = settings.sizeY1;
            document.getElementById('sizeX2').value = settings.sizeX2;
            document.getElementById('sizeY2').value = settings.sizeY2;
            document.getElementById('backgroundColor').value = settings.backgroundColor;

            updateRangeValues();
        }

        // レンジ値の表示更新
        function updateRangeValues() {
            document.getElementById('brightnessValue').textContent = document.getElementById('brightness').value + '%';
            document.getElementById('contrastValue').textContent = document.getElementById('contrast').value + '%';
            document.getElementById('hueRotateValue').textContent = document.getElementById('hueRotate').value + '°';
            document.getElementById('saturateValue').textContent = document.getElementById('saturate').value + '%';
            document.getElementById('blurValue').textContent = document.getElementById('blur').value + 'px';
            document.getElementById('sepiaValue').textContent = document.getElementById('sepia').value + '%';
            document.getElementById('grayscaleValue').textContent = document.getElementById('grayscale').value + '%';
            document.getElementById('opacityValue').textContent = document.getElementById('opacity').value + '%';
            document.getElementById('invertValue').textContent = document.getElementById('invert').value + '%';
        }

        // カメラチェックボックスリストの更新
        function updateCameraCheckboxList() {
            const list = document.getElementById('cameraCheckboxList');
            list.innerHTML = '';

            allCameras.forEach(camera => {
                const item = document.createElement('div');
                item.className = 'checkbox-item';
                
                const checkbox = document.createElement('input');
                checkbox.type = 'checkbox';
                checkbox.id = `camera_${camera.deviceId}`;
                checkbox.checked = selectedCameras.some(c => c.deviceId === camera.deviceId);
                checkbox.onchange = async (e) => {
                    if (e.target.checked) {
                        selectedCameras.push(camera);
                    } else {
                        selectedCameras = selectedCameras.filter(c => c.deviceId !== camera.deviceId);
                    }
                    
                    if (selectedCameras.length > 0) {
                        if (currentCameraIndex >= selectedCameras.length) {
                            currentCameraIndex = selectedCameras.length - 1;
                        }
                        const currentCamera = selectedCameras[currentCameraIndex];
                        await startCamera(currentCamera.deviceId);
                    }
                    
                    saveSettings();
                };
                
                const label = document.createElement('label');
                label.htmlFor = `camera_${camera.deviceId}`;
                label.textContent = camera.label || `カメラ ${camera.deviceId}`;
                
                item.appendChild(checkbox);
                item.appendChild(label);
                list.appendChild(item);
            });
        }

        // 初期カメラ選択画面の表示
        async function showInitialCameraSelection() {
            allCameras = await getCameras();
            
            const list = document.getElementById('initialCameraList');
            list.innerHTML = '';

            allCameras.forEach(camera => {
                const item = document.createElement('div');
                item.className = 'checkbox-item';
                
                const checkbox = document.createElement('input');
                checkbox.type = 'checkbox';
                checkbox.id = `initial_camera_${camera.deviceId}`;
                checkbox.value = camera.deviceId;
                
                const label = document.createElement('label');
                label.htmlFor = `initial_camera_${camera.deviceId}`;
                label.textContent = camera.label || `カメラ ${camera.deviceId}`;
                
                item.appendChild(checkbox);
                item.appendChild(label);
                list.appendChild(item);
            });

            document.getElementById('cameraSelection').classList.add('open');
        }

        // 初期カメラ選択の確定
        async function confirmInitialCameraSelection() {
            const checkboxes = document.querySelectorAll('#initialCameraList input[type="checkbox"]:checked');
            selectedCameras = Array.from(checkboxes).map(cb => {
                return allCameras.find(c => c.deviceId === cb.value);
            });

            if (selectedCameras.length === 0) {
                alert('少なくとも1つのカメラを選択してください');
                return;
            }

            document.getElementById('cameraSelection').classList.remove('open');
            currentCameraIndex = 0;
            await startCamera(selectedCameras[0].deviceId);
            updateCameraCheckboxList();
            saveSettings();
        }

        // エクスポート
        function exportSettings() {
            const settings = {
                cameraSettings,
                selectedCameras: selectedCameras.map(c => ({ deviceId: c.deviceId, label: c.label })),
                currentCameraIndex,
                mqttSettings: getMqttSettings()
            };
            
            const json = JSON.stringify(settings, null, 2);
            document.getElementById('settingsJson').value = json;
            
            // ファイルダウンロード
            const blob = new Blob([json], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            const date = new Date().toISOString().slice(0, 10).replace(/-/g, '');
            a.href = url;
            a.download = `camview-settings-${date}.json`;
            a.click();
            URL.revokeObjectURL(url);
        }

        // インポート
        async function importSettings() {
            const json = document.getElementById('settingsJson').value;
            if (!json) {
                alert('設定JSONを入力してください');
                return;
            }

            try {
                const settings = JSON.parse(json);
                cameraSettings = settings.cameraSettings || {};
                currentCameraIndex = settings.currentCameraIndex || 0;
                
                if (settings.mqttSettings) {
                    saveMqttSettings(settings.mqttSettings);
                }
                
                // selectedCamerasの復元
                if (settings.selectedCameras) {
                    selectedCameras = [];
                    for (const saved of settings.selectedCameras) {
                        const camera = allCameras.find(c => c.deviceId === saved.deviceId);
                        if (camera) {
                            selectedCameras.push(camera);
                        }
                    }
                }
                
                saveSettings();
                
                if (selectedCameras.length > 0) {
                    await startCamera(selectedCameras[currentCameraIndex].deviceId);
                }
                
                updateCameraCheckboxList();
                loadSettingsToUI();
                
                // MQTT再接続
                const mqttSettings = getMqttSettings();
                if (mqttSettings) {
                    connectMqtt(mqttSettings);
                }
                
                alert('設定をインポートしました');
            } catch (error) {
                alert('設定のインポートに失敗しました: ' + error.message);
            }
        }

        // フルスクリーン切り替え
        function toggleFullscreen() {
            if (!document.fullscreenElement) {
                document.documentElement.requestFullscreen();
            } else {
                document.exitFullscreen();
            }
        }

        // イベントリスナーの設定
        function setupEventListeners() {
            // キーボードイベント
            document.addEventListener('keydown', (e) => {
                if (e.key === 'ArrowLeft') {
                    e.preventDefault();
                    if (!isPlayingRecording) switchCamera(-1);
                } else if (e.key === 'ArrowRight') {
                    e.preventDefault();
                    if (!isPlayingRecording) switchCamera(1);
                } else if (e.key === 's' || e.key === 'S') {
                    e.preventDefault();
                    const panel = document.getElementById('settingsPanel');
                    if (panel.classList.contains('open')) {
                        closeSettings();
                    } else {
                        openSettings();
                    }
                } else if (e.key === 'Escape') {
                    if (isPlayingRecording) {
                        stopPlayback();
                    } else if (document.getElementById('settingsPanel').classList.contains('open')) {
                        closeSettings();
                    }
                } else if (e.key === 'f' || e.key === 'F') {
                    e.preventDefault();
                    toggleFullscreen();
                } else if (e.key === 'r' || e.key === 'R') {
                    e.preventDefault();
                    if (mediaRecorder && mediaRecorder.state === 'recording') {
                        stopRecording();
                    } else {
                        startRecording();
                    }
                }
            });

            // 設定ボタン
            document.getElementById('settingsButton').onclick = openSettings;
            document.getElementById('closeSettings').onclick = closeSettings;

            // MQTT設定
            document.getElementById('openMqttSettings').onclick = openMqttSettingsModal;

            // モーダル
            document.getElementById('modalCancel').onclick = closeModal;

            // エクスポート/インポート
            document.getElementById('exportSettings').onclick = exportSettings;
            document.getElementById('importSettings').onclick = importSettings;

            // 初期カメラ選択
            document.getElementById('confirmCameraSelection').onclick = confirmInitialCameraSelection;

            // レンジ入力の値表示更新とリアルタイム反映
            const ranges = ['brightness', 'contrast', 'hueRotate', 'saturate', 'blur', 
                           'sepia', 'grayscale', 'opacity', 'invert'];
            ranges.forEach(id => {
                document.getElementById(id).addEventListener('input', () => {
                    updateRangeValues();
                    applyVideoSettingsRealtime();
                });
            });
            
            // チェックボックスとセレクトのリアルタイム反映
            ['flipH', 'flipV'].forEach(id => {
                document.getElementById(id).addEventListener('change', applyVideoSettingsRealtime);
            });
            document.getElementById('rotate').addEventListener('change', applyVideoSettingsRealtime);
            document.getElementById('backgroundColor').addEventListener('input', applyVideoSettingsRealtime);
            
            // 表示領域のリアルタイム反映
            ['sizeX1', 'sizeY1', 'sizeX2', 'sizeY2'].forEach(id => {
                document.getElementById(id).addEventListener('input', applyVideoSettingsRealtime);
            });
            
            // ウィンドウリサイズイベント
            window.addEventListener('resize', handleResize);
        }
        
        // リアルタイムで設定を反映（保存はしない）
        function applyVideoSettingsRealtime() {
            const camera = selectedCameras[currentCameraIndex];
            if (!camera) return;

            const settings = {
                flipH: document.getElementById('flipH').checked,
                flipV: document.getElementById('flipV').checked,
                rotate: parseInt(document.getElementById('rotate').value),
                brightness: parseInt(document.getElementById('brightness').value),
                contrast: parseInt(document.getElementById('contrast').value),
                hueRotate: parseInt(document.getElementById('hueRotate').value),
                saturate: parseInt(document.getElementById('saturate').value),
                blur: parseInt(document.getElementById('blur').value),
                sepia: parseInt(document.getElementById('sepia').value),
                grayscale: parseInt(document.getElementById('grayscale').value),
                opacity: parseInt(document.getElementById('opacity').value),
                invert: parseInt(document.getElementById('invert').value),
                sizeX1: parseInt(document.getElementById('sizeX1').value) || 0,
                sizeY1: parseInt(document.getElementById('sizeY1').value) || 0,
                sizeX2: parseInt(document.getElementById('sizeX2').value) || 1920,
                sizeY2: parseInt(document.getElementById('sizeY2').value) || 1080,
                backgroundColor: document.getElementById('backgroundColor').value
            };

            const video = document.getElementById('video');

            // フィルター適用
            let filters = [];
            filters.push(`brightness(${settings.brightness}%)`);
            filters.push(`contrast(${settings.contrast}%)`);
            filters.push(`hue-rotate(${settings.hueRotate}deg)`);
            filters.push(`saturate(${settings.saturate}%)`);
            filters.push(`blur(${settings.blur}px)`);
            filters.push(`sepia(${settings.sepia}%)`);
            filters.push(`grayscale(${settings.grayscale}%)`);
            filters.push(`opacity(${settings.opacity}%)`);
            filters.push(`invert(${settings.invert}%)`);
            video.style.filter = filters.join(' ');

            // 変形・回転
            let transform = [];
            if (settings.flipH) transform.push('scaleX(-1)');
            if (settings.flipV) transform.push('scaleY(-1)');
            if (settings.rotate !== 0) transform.push(`rotate(${settings.rotate}deg)`);
            video.style.transform = transform.join(' ');

            // 表示領域（クロップ）
            applyVideoCrop(settings);
        }
        
        // ウィンドウリサイズ時の処理
        function handleResize() {
            if (selectedCameras.length > 0 && selectedCameras[currentCameraIndex]) {
                applyVideoSettings();
            }
        }

        // 初期化
        async function init() {
            await initDB();
            setupEventListeners();
            
            const settings = loadSettings();
            allCameras = await getCameras();
            
            if (settings && settings.selectedCameras && settings.selectedCameras.length > 0) {
                // 保存された設定からカメラを復元
                selectedCameras = [];
                for (const saved of settings.selectedCameras) {
                    const camera = allCameras.find(c => c.deviceId === saved.deviceId);
                    if (camera) {
                        selectedCameras.push(camera);
                    }
                }
                
                if (selectedCameras.length > 0) {
                    currentCameraIndex = Math.min(settings.currentCameraIndex || 0, selectedCameras.length - 1);
                    await startCamera(selectedCameras[currentCameraIndex].deviceId);
                    updateCameraCheckboxList();
                    
                    // MQTT自動接続
                    const mqttSettings = getMqttSettings();
                    if (mqttSettings) {
                        connectMqtt(mqttSettings);
                    }
                } else {
                    showInitialCameraSelection();
                }
            } else {
                showInitialCameraSelection();
            }
        }

        // ページ読み込み時に初期化
        window.addEventListener('load', init);

        // ページ離脱時のクリーンアップ
        window.addEventListener('beforeunload', () => {
            if (mediaStream) {
                mediaStream.getTracks().forEach(track => track.stop());
            }
            if (mqttClient) {
                mqttClient.end();
            }
        });
    </script>
</body>
</html>
